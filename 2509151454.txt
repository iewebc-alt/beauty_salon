==================================================
           DUMPING PROJECT FILE CONTENTS
==================================================


--- START OF FILE docker-compose.yml ---
services:
  db:
    image: postgres:14-alpine
    container_name: salon_postgres_db
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "5432:5432"
    restart: unless-stopped
#    healthcheck:
#      test: ["CMD-SHELL", "pg_isready -U $$  {POSTGRES_USER} -d   $${POSTGRES_DB}"]
#      interval: 5s
#      timeout: 5s
#      retries: 5
    networks:
      - salon_network

  redis:
    image: redis:7-alpine
    container_name: salon_redis
    volumes:
      - redis_data:/data
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    command: redis-server --requirepass ${REDIS_PASSWORD}
    restart: unless-stopped
    networks:
      - salon_network

  api:
    build: .
    container_name: salon_api_service
    command: >
      sh -c "if [ \"$ENVIRONMENT\" = \"prod\" ]; then
               uvicorn api.main:app --host 0.0.0.0 --port 8000;
             else
               uvicorn api.main:app --host 0.0.0.0 --port 8000 --reload;
             fi"
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
    environment:
      - DB_USER=${DB_USER}
      - DB_PASSWORD=${DB_PASSWORD}
      - DB_NAME=${DB_NAME}
      - ADMIN_USERNAME=${ADMIN_USERNAME}
      - ADMIN_PASSWORD=${ADMIN_PASSWORD}
      - RUNNING_IN_DOCKER=1
      - ENVIRONMENT=${ENVIRONMENT}
      - DEBUG=${DEBUG}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - salon_network

  bot:
    build: .
    container_name: salon_telegram_bot
    command: python3 bot.py
    volumes:
      - .:/app
    depends_on:
      - api
      - redis
    environment:
      - BOT_TOKEN=${BOT_TOKEN}
      - GEMINI_API_KEY=${GEMINI_API_KEY}
      - API_URL=http://api:8000
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - ENVIRONMENT=${ENVIRONMENT}
      - DEBUG=${DEBUG}
    restart: unless-stopped
    networks:
      - salon_network

volumes:
  postgres_data:
  redis_data:

networks:
  salon_network:
    driver: bridge


--- START OF FILE requirements.txt ---
aiofiles==24.1.0
aiogram==3.22.0
google-generativeai==0.5.2
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bcrypt==4.3.0
certifi==2025.8.3
click==8.2.1
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
httpcore==1.0.9
httpx==0.28.1
idna==3.10
Jinja2==3.1.6
magic-filter==1.0.12
MarkupSafe==3.0.2
multidict==6.6.4
passlib==1.7.4
propcache==0.3.2
psycopg2-binary==2.9.10
pydantic==2.8.2
pydantic_core==2.20.1
python-dotenv==1.1.1
python-multipart==0.0.20
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
typing-inspection==0.4.1
typing_extensions==4.15.0
uvicorn==0.35.0
yarl==1.20.1
redis==5.0.1
pytest==8.3.3
pytest-asyncio==0.24.0
babel==2.15.0


--- START OF FILE config.py ---
import os
from datetime import timezone
from dotenv import load_dotenv

load_dotenv()

# --- UTC ---
UTC = timezone.utc

# --- –ë–∞–∑–∞ –î–∞–Ω–Ω—ã—Ö ---
DB_USER = os.getenv("DB_USER")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_NAME = os.getenv("DB_NAME")

# –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è RUNNING_IN_DOCKER —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º 'db'.
# –ò–Ω–∞—á–µ (–ø—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–ø—É—Å–∫–µ) –∏—Å–ø–æ–ª—å–∑—É–µ–º 'localhost'.
if os.getenv("RUNNING_IN_DOCKER"):
    DB_HOST = os.getenv("DB_HOST", "db")
else:
    DB_HOST = "localhost"

DATABASE_URL = f"postgresql+psycopg2://{DB_USER}:{DB_PASSWORD}@{DB_HOST}/{DB_NAME}"

# --- Telegram –ë–æ—Ç ---
BOT_TOKEN = os.getenv("BOT_TOKEN")
API_URL = os.getenv("API_URL


--- START OF FILE database.py ---
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from config import DATABASE_URL

Base = declarative_base()  # –ü–µ—Ä–µ–º–µ—Å—Ç–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ Base —Å—é–¥–∞

SessionLocal = sessionmaker(autocommit=False, autoflush=False)

def get_engine():
    return create_engine(DATABASE_URL)


--- START OF FILE models.py ---
# models.py
from sqlalchemy import (
    Column,
    Integer,
    String,
    Text,
    ForeignKey,
    Table,
    BigInteger,
    Time,
    Date,
    DateTime
)
from sqlalchemy.orm import relationship
from database import Base

# –ê—Å—Å–æ—Ü–∏–∞—Ü–∏—è –º–∞—Å—Ç–µ—Ä–æ–≤ –∏ —É—Å–ª—É–≥
master_services = Table(
    'master_services',
    Base.metadata,
    Column('master_id', Integer, ForeignKey('masters.id'), primary_key=True),
    Column('service_id', Integer, ForeignKey('services.id'), primary_key=True)
)

class Client(Base):
    __tablename__ = "clients"
    id = Column(Integer, primary_key=True, index=True)
    telegram_user_id = Column(BigInteger, unique=True, nullable=False)
    name = Column(String(255))
    phone_number = Column(String(20))
    appointments = relationship("Appointment", back_populates="client")

class Service(Base):
    __tablename__ = "services"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), index=True)
    price = Column(Integer)
    duration_minutes = Column(Integer)
    masters = relationship("Master", secondary=master_services, back_populates="services")
    appointments = relationship("Appointment", back_populates="service")

class Master(Base):
    __tablename__ = "masters"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), index=True)
    specialization = Column(String(255))
    description = Column(Text, nullable=True)
    services = relationship("Service", secondary=master_services, back_populates="masters")
    schedules = relationship("Schedule", back_populates="master")
    appointments = relationship("Appointment", back_populates="master")

class Schedule(Base):
    __tablename__ = "schedules"
    id = Column(Integer, primary_key=True)
    master_id = Column(Integer, ForeignKey('masters.id'))
    day_of_week = Column(Integer, nullable=False)  # 1=–ü–Ω, 7=–í—Å
    start_time = Column(Time, nullable=False)
    end_time = Column(Time, nullable=False)
    master = relationship("Master", back_populates="schedules")

class Appointment(Base):
    __tablename__ = "appointments"
    id = Column(Integer, primary_key=True)
    client_id = Column(Integer, ForeignKey('clients.id'))
    master_id = Column(Integer, ForeignKey('masters.id'))
    service_id = Column(Integer, ForeignKey('services.id'))
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    client = relationship("Client", back_populates="appointments")
    master = relationship("Master", back_populates="appointments")
    service = relationship("Service", back_populates="appointments")


--- START OF FILE fsm.py ---
# fsm.py - –ó–¥–µ—Å—å –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è –º–∞—à–∏–Ω—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π (FSM).
from aiogram.fsm.state import State, StatesGroup

class AppointmentStates(StatesGroup):
    choosing_service = State()
    choosing_master = State()
    choosing_date = State()
    choosing_time = State()
    confirmation = State()
    awaiting_contact = State() # <-- –î–û–ë–ê–í–¨–¢–ï –≠–¢–£ –°–¢–†–û–ö–£


--- START OF FILE keyboards.py ---
# keyboards.py - –≠—Ç–æ—Ç —Ñ–∞–π–ª –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä, –≤ –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ ‚Äî –∫–∞–ª–µ–Ω–¥–∞—Ä—è.
import calendar
from aiogram import types
from aiogram.utils.keyboard import InlineKeyboardBuilder

def create_calendar_keyboard(year: int, month: int, active_days: set = None) -> types.InlineKeyboardMarkup:
    if active_days is None:
        active_days = set()
    builder = InlineKeyboardBuilder()
    month_names_ru = [
        "", "–Ø–Ω–≤–∞—Ä—å", "–§–µ–≤—Ä–∞–ª—å", "–ú–∞—Ä—Ç", "–ê–ø—Ä–µ–ª—å", "–ú–∞–π", "–ò—é–Ω—å",
        "–ò—é–ª—å", "–ê–≤–≥—É—Å—Ç", "–°–µ–Ω—Ç—è–±—Ä—å", "–û–∫—Ç—è–±—Ä—å", "–ù–æ—è–±—Ä—å", "–î–µ–∫–∞–±—Ä—å"
    ]
    month_name = month_names_ru[month]
    builder.row(types.InlineKeyboardButton(text=f"{month_name} {year}", callback_data="ignore"))
    days_of_week = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    builder.row(*[types.InlineKeyboardButton(text=day, callback_data="ignore") for day in days_of_week])
    month_calendar = calendar.monthcalendar(year, month)
    for week in month_calendar:
        row_buttons = []
        for day in week:
            if day == 0:
                row_buttons.append(types.InlineKeyboardButton(text=" ", callback_data="ignore"))
            elif day in active_days:
                row_buttons.append(types.InlineKeyboardButton(text=f"‚úÖ{day}", callback_data=f"cal_day:{year}:{month}:{day}"))
            else:
                row_buttons.append(types.InlineKeyboardButton(text=str(day), callback_data="ignore_inactive_day"))
        builder.row(*row_buttons)
    prev_month, prev_year = (month - 1, year) if month > 1 else (12, year - 1)
    next_month, next_year = (month + 1, year) if month < 12 else (1, year + 1)
    builder.row(
        types.InlineKeyboardButton(text="< –ù–∞–∑–∞–¥", callback_data=f"cal_nav:{prev_year}:{prev_month}"),
        types.InlineKeyboardButton(text="–í–ø–µ—Ä–µ–¥ >", callback_data=f"cal_nav:{next_year}:{next_month}")
    )
    return builder.as_markup()


--- START OF FILE bot.py ---
# bot.py
import asyncio
import logging
import locale

from aiogram import Bot, Dispatcher, types
from aiogram.fsm.storage.redis import RedisStorage
from redis.asyncio.client import Redis

from config import BOT_TOKEN, REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, DEBUG
from handlers import common, appointments, booking

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.DEBUG if DEBUG else logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s'
)

async def main():
    bot = Bot(token=BOT_TOKEN)
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Redis Storage
    redis_client = Redis(
        host=REDIS_HOST,
        port=REDIS_PORT,
        password=REDIS_PASSWORD if REDIS_PASSWORD else None
    )
    storage = RedisStorage(redis=redis_client)
    
    dp = Dispatcher(storage=storage)

    dp.include_router(booking.router)
    dp.include_router(appointments.router)
    dp.include_router(common.router)

    await bot.set_my_commands([
        types.BotCommand(command="start", description="–ù–∞—á–∞–ª–æ —Ä–∞–±–æ—Ç—ã"),
        types.BotCommand(command="book", description="–ó–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É—Å–ª—É–≥—É"),
        types.BotCommand(command="my_appointments", description="–ú–æ–∏ –∑–∞–ø–∏—Å–∏"),
        types.BotCommand(command="cancel", description="–û—Ç–º–µ–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ"),
    ])

    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
    except locale.Error:
        logging.warning("–õ–æ–∫–∞–ª—å ru_RU.UTF-8 –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –º–µ—Å—è—Ü—ã –º–æ–≥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º.")
    
    asyncio.run(main())


--- START OF FILE setup.py ---
from setuptools import setup, find_packages

setup(
    name="beauty_salon_project",
    version="0.1.0",
    packages=find_packages(),
)


--- START OF FILE pytest.ini ---
[pytest]
pythonpath = .
addopts = --import-mode=append

#   **`[pytest]`**: –≠—Ç–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–µ–∫—Ü–∏–∏ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ `pytest`.
#   **`pythonpath = .`**: –≠—Ç–æ –∏ –µ—Å—Ç—å "–º–∞–≥–∏—è". –≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –≥–æ–≤–æ—Ä–∏—Ç `pytest`: "–ü–µ—Ä–µ–¥ —Ç–µ–º –∫–∞–∫ –∑–∞–ø—É—Å–∫–∞—Ç—å —Ç–µ—Å—Ç—ã, –¥–æ–±–∞–≤—å –≤ —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—É—Ç—å –ø–æ–∏—Å–∫–∞ –º–æ–¥—É–ª–µ–π (`PYTHONPATH`) —Ç–µ–∫—É—â—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é (`.`)".



--- START OF FILE api/main.py ---
# api/main.py
import logging
from fastapi import FastAPI, Request, Depends
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session, joinedload
from typing import Optional
from datetime import date, datetime, time, timedelta
from contextlib import asynccontextmanager

import models
from database import SessionLocal, Base, get_engine
from api.routers import bot
from api.dependencies import authenticate_user, get_db
from config import ADMIN_USERNAME, ADMIN_PASSWORD, ENVIRONMENT, DEBUG

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.DEBUG if DEBUG else logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s'
)

@asynccontextmanager
async def lifespan(app: FastAPI):
    logging.info("Application startup...")
    engine = get_engine()
    SessionLocal.configure(bind=engine)
    Base.metadata.create_all(bind=engine)
    
    with SessionLocal() as db:
        create_initial_data(db)
    yield
    logging.info("Application shutdown...")

app = FastAPI(title="Beauty Salon API", lifespan=lifespan)

def create_initial_data(db: Session):
    """–ó–∞–ø–æ–ª–Ω—è–µ—Ç –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏, –µ—Å–ª–∏ –æ–Ω–∞ –ø—É—Å—Ç–∞."""
    if db.query(models.Service).count() == 0:
        logging.info("Creating initial services data...")
        db.add_all([
            models.Service(name="–ú–∞–Ω–∏–∫—é—Ä —Å –ø–æ–∫—Ä—ã—Ç–∏–µ–º", price=2000, duration_minutes=90),
            models.Service(name="–ñ–µ–Ω—Å–∫–∞—è —Å—Ç—Ä–∏–∂–∫–∞", price=2500, duration_minutes=60),
            models.Service(name="–ß–∏—Å—Ç–∫–∞ –ª–∏—Ü–∞", price=3500, duration_minutes=75),
            models.Service(name="–ù–∞—Ä–∞—â–∏–≤–∞–Ω–∏–µ —Ä–µ—Å–Ω–∏—Ü", price=3000, duration_minutes=120),
            models.Service(name="–û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –±—Ä–æ–≤–µ–π", price=1500, duration_minutes=45),
            models.Service(name="–î–µ–ø–∏–ª—è—Ü–∏—è", price=3000, duration_minutes=60)
        ])
        db.commit()
    
    if db.query(models.Master).count() == 0:
        logging.info("Creating initial masters data...")
        s_manicure=db.query(models.Service).filter_by(name="–ú–∞–Ω–∏–∫—é—Ä —Å –ø–æ–∫—Ä—ã—Ç–∏–µ–º").one()
        s_haircut=db.query(models.Service).filter_by(name="–ñ–µ–Ω—Å–∫–∞—è —Å—Ç—Ä–∏–∂–∫–∞").one()
        s_facial=db.query(models.Service).filter_by(name="–ß–∏—Å—Ç–∫–∞ –ª–∏—Ü–∞").one()
        s_eyelash=db.query(models.Service).filter_by(name="–ù–∞—Ä–∞—â–∏–≤–∞–Ω–∏–µ —Ä–µ—Å–Ω–∏—Ü").one()
        s_eyebrow=db.query(models.Service).filter_by(name="–û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –±—Ä–æ–≤–µ–π").one()
        s_depilation=db.query(models.Service).filter_by(name="–î–µ–ø–∏–ª—è—Ü–∏—è").one()

        m1=models.Master(name="–ê–Ω–Ω–∞ –°–º–∏—Ä–Ω–æ–≤–∞", specialization="–ú–∞—Å—Ç–µ—Ä –º–∞–Ω–∏–∫—é—Ä–∞", description="–û–ø—ã—Ç 5 –ª–µ—Ç.")
        m2=models.Master(name="–ï–ª–µ–Ω–∞ –í–æ–ª–∫–æ–≤–∞", specialization="–ü–∞—Ä–∏–∫–º–∞—Ö–µ—Ä-—Å—Ç–∏–ª–∏—Å—Ç", description="–°–ª–æ–∂–Ω—ã–µ –æ–∫—Ä–∞—à–∏–≤–∞–Ω–∏—è.")
        m3=models.Master(name="–û–ª—å–≥–∞ –ú–æ—Ä–æ–∑–æ–≤–∞", specialization="–ö–æ—Å–º–µ—Ç–æ–ª–æ–≥-—ç—Å—Ç–µ—Ç–∏—Å—Ç", description="–ú–µ–¥–∏—Ü–∏–Ω—Å–∫–æ–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ.")
        m4=models.Master(name="–ò—Ä–∏–Ω–∞ –ü–∞–≤–ª–æ–≤–∞", specialization="–õ–µ—à–º–µ–π–∫–µ—Ä –∏ –±—Ä–æ–≤–∏—Å—Ç", description="–ß–µ–º–ø–∏–æ–Ω–∫–∞ –∫–æ–Ω–∫—É—Ä—Å–æ–≤.")
        
        db.add_all([m1, m2, m3, m4]); db.commit()
        
        m1.services.extend([s_manicure, s_eyebrow])
        m2.services.append(s_haircut)
        m3.services.extend([s_facial, s_depilation, s_eyebrow])
        m4.services.extend([s_eyelash, s_eyebrow])
        db.commit()
        
        schedules = [
            models.Schedule(master_id=m1.id,day_of_week=d,start_time=time(10,0),end_time=time(19,0)) for d in [1,3,5]
        ]
        schedules.extend([
            models.Schedule(master_id=m2.id,day_of_week=d,start_time=time(9,0),end_time=time(18,0)) for d in [2,4,6]
        ])
        schedules.extend([
            models.Schedule(master_id=m3.id,day_of_week=d,start_time=time(10,0),end_time=time(20,0)) for d in [3,5]
        ])
        schedules.extend([
            models.Schedule(master_id=m4.id,day_of_week=d,start_time=time(11,0),end_time=time(20,0)) for d in [1,3,5,7]
        ])
        
        db.add_all(schedules); db.commit()
        logging.info("Initial data created for testing.")

app.include_router(bot.router)

app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

@app.get("/")
def read_root():
    return {"message": "Beauty Salon API is running"}

@app.get("/admin/schedule", include_in_schema=False)
def admin_schedule_page(
    request: Request, 
    selected_date_str: Optional[str] = None, 
    db: Session = Depends(get_db), 
    username: str = Depends(authenticate_user)
):
    try:
        selected_date = datetime.strptime(selected_date_str, "%Y-%m-%d").date() if selected_date_str else date.today()
    except ValueError:
        selected_date = date.today()
    
    prev_date = selected_date - timedelta(days=1)
    next_date = selected_date + timedelta(days=1)
    
    masters = db.query(models.Master).order_by(models.Master.name).all()
    
    start_of_day = datetime.combine(selected_date, time.min)
    end_of_day = datetime.combine(selected_date, time.max)
    
    appointments = db.query(models.Appointment).options(
        joinedload(models.Appointment.client), 
        joinedload(models.Appointment.service)
    ).filter(
        models.Appointment.start_time.between(start_of_day, end_of_day)
    ).order_by(models.Appointment.start_time).all()
    
    all_services = db.query(models.Service).order_by(models.Service.name).all()
    
    context = {
        "request": request,
        "selected_date": selected_date,
        "prev_date": prev_date,
        "next_date": next_date,
        "masters": masters,
        "appointments": appointments,
        "all_services": all_services,
        "all_masters": masters
    }
    return templates.TemplateResponse("schedule.html", context)


--- START OF FILE api/dependencies.py ---
# api/dependencies.py
import secrets
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from sqlalchemy.orm import Session

from database import SessionLocal
from config import ADMIN_USERNAME, ADMIN_PASSWORD

# --- Dependency –ë–î ---
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å ---
security = HTTPBasic() # <--- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–ï–°–¨: –î–æ–±–∞–≤–ª—è–µ–º —ç—Ç—É —Å—Ç—Ä–æ–∫—É

def authenticate_user(credentials: HTTPBasicCredentials = Depends(security)):
    is_username_correct = secrets.compare_digest(credentials.username, ADMIN_USERNAME)
    is_password_correct = secrets.compare_digest(credentials.password, ADMIN_PASSWORD)
    if not (is_username_correct and is_password_correct):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username


--- START OF FILE api/schemas.py ---
# api/schemas.py
from pydantic import BaseModel, ConfigDict # <-- 1. –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º ConfigDict
from typing import List, Optional
from datetime import datetime

class ServiceSchema(BaseModel):
    id: int; name: str; price: int; duration_minutes: int
    model_config = ConfigDict(from_attributes=True) # <-- 2. –ó–∞–º–µ–Ω—è–µ–º class Config

class MasterSchema(BaseModel):
    id: int; name: str; specialization: str; description: Optional[str] = None
    model_config = ConfigDict(from_attributes=True)

class AppointmentInfoSchema(BaseModel):
    id: int; start_time: datetime; service_name: str; master_name: str
    model_config = ConfigDict(from_attributes=True)

class AppointmentCreateSchema(BaseModel):
    telegram_user_id: int; user_name: str; service_id: int; master_id: int; start_time: datetime

class ClientUpdateSchema(BaseModel):
    phone_number: str

class AvailableSlotSchema(BaseModel):
    time: str; master_id: int

class AppointmentNaturalLanguageSchema(BaseModel):
    telegram_user_id: int; user_name: str; service_name: str; appointment_date: str; appointment_time: str; master_name: Optional[str] = None

class SimpleServiceSchema(BaseModel):
    name: str; price: int; duration_minutes: int
    model_config = ConfigDict(from_attributes=True)

class SimpleMasterSchema(BaseModel):
    name: str; specialization: str; services: list[str]

class SalonInfoSchema(BaseModel):
    services: list[SimpleServiceSchema]; masters: list[SimpleMasterSchema]


--- START OF FILE api/routers/bot.py ---
# api/routers/bot.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session, joinedload
from typing import List, Optional
from datetime import date, datetime, time, timedelta
import calendar
import logging
from config import UTC

import models
from api import schemas
from api.dependencies import get_db

router = APIRouter(
    prefix="/api/v1",
    tags=["Bot API"],
)

@router.get("/services", response_model=List[schemas.ServiceSchema])
def get_services(db: Session = Depends(get_db)):
    return db.query(models.Service### –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –æ—à–∏–±–∫–∏
–í–∞—à —Å–∫—Ä–∏–ø—Ç –∑–∞–ø—É—Å—Ç–∏–ª—Å—è —É—Å–ø–µ—à–Ω–æ –Ω–∞ —ç—Ç–∞–ø–µ –±—ç–∫–∞–ø–∞ (–≤—Å–µ —Ñ–∞–π–ª—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –≤ `backup_20250915_074522/`), –Ω–æ —É–ø–∞–ª –Ω–∞ —ç—Ç–∞–ø–µ –∑–∞–º–µ–Ω—ã —Ñ–∞–π–ª–æ–≤ –∏–∑-–∑–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è **"here-document at line 157 delimited by end-of-file (wanted `EOF')"**. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –æ–¥–∏–Ω –∏–∑ –±–ª–æ–∫–æ–≤ `cat << 'EOF' > filename` (heredoc) –Ω–µ –±—ã–ª –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∑–∞–∫—Ä—ã—Ç —Ç–µ–≥–æ–º `EOF` –≤ –∫–æ–Ω—Ü–µ ‚Äî —Å–∫—Ä–∏–ø—Ç –±—ã–ª –æ–±—Ä–µ–∑–∞–Ω –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥—ë–Ω –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ (–≤–µ—Ä–æ—è—Ç–Ω–æ, handlers/booking.py, –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ñ–∞–π–ª –≤ —Å–ø–∏—Å–∫–µ).

**–ß—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ:**
- –ë—ç–∫–∞–ø –∑–∞–≤–µ—Ä—à—ë–Ω ‚úÖ (–≤—ã –º–æ–∂–µ—Ç–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å: `cp -r backup_20250915_074522/* .`).
- –ó–∞–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤ –Ω–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –∏–∑-–∑–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏ –≤ bash.
- –§–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞ –æ—Å—Ç–∞–ª–∏—Å—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–º–∏.

**–†–µ—à–µ–Ω–∏–µ:** –ù–∏–∂–µ –ø–æ–ª–Ω—ã–π –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç `deploy_fixes.sh` –±–µ–∑ –æ–±—Ä–µ–∑–∫–∏. –Ø:
- –î–æ–±–∞–≤–∏–ª `mkdir -p` –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –≤ –±—ç–∫–∞–ø–µ (—á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ –≤—Ä–æ–¥–µ "No such file or directory").
- –£–±–µ–¥–∏–ª—Å—è, —á—Ç–æ **–≤—Å–µ heredoc –∑–∞–∫—Ä—ã—Ç—ã `EOF`** (–ø—Ä–æ–≤–µ—Ä–∏–ª —Å—Ç—Ä—É–∫—Ç—É—Ä—É).
- –î–æ–±–∞–≤–∏–ª —Å–æ–∑–¥–∞–Ω–∏–µ `.env` (–µ—Å–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç) —Å –ø—Ä–∏–º–µ—Ä–æ–º –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π ‚Äî –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ –µ–≥–æ –≤—Ä—É—á–Ω—É—é –ø–æ—Å–ª–µ.
- –î–æ–±–∞–≤–∏–ª –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (`pip install -r requirements.txt`).
- –î–æ–±–∞–≤–∏–ª –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ `docker-compose up --build -d` (background) —Å –≤–æ–ø—Ä–æ—Å–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.
- –î–æ–±–∞–≤–∏–ª –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –ø–µ—Ä–µ–¥ –∑–∞–º–µ–Ω–æ–π.
- –°–¥–µ–ª–∞–ª —Å–∫—Ä–∏–ø—Ç –±–æ–ª–µ–µ robust: `-e` –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∞ –æ—à–∏–±–∫–∞—Ö, –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ.

### –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –∑–∞–ø—É—Å–∫—É
1. **–û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Ç–µ–∫—É—â–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã (–µ—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω—ã):** `docker-compose down`.
2. **–°–æ–∑–¥–∞–π—Ç–µ/–∑–∞–º–µ–Ω–∏—Ç–µ —Å–∫—Ä–∏–ø—Ç:**
   - `nano deploy_fixes_fixed.sh` (–≤—Å—Ç–∞–≤—å—Ç–µ –∫–æ–¥ –Ω–∏–∂–µ).
   - `chmod +x deploy_fixes_fixed.sh`.
   - `./deploy_fixes_fixed.sh`.
3. **–ü–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞:**
   - –û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ `.env` (—Ç–æ–∫–µ–Ω—ã, –ø–∞—Ä–æ–ª–∏).
   - `docker-compose up --build -d`.
   - –¢–µ—Å—Ç—ã: `pytest -v`.
4. **–ï—Å–ª–∏ –æ—à–∏–±–∫–∞ persists:** –ü–æ–∫–∞–∂–∏—Ç–µ `head -50 deploy_fixes.sh` –∏ `tail -50 deploy_fixes.sh` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ EOF.

### –ü–æ–ª–Ω—ã–π –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–∫—Ä–∏–ø—Ç `deploy_fixes_fixed.sh`
–°–∫–æ–ø–∏—Ä—É–π—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ —Ü–µ–ª–∏–∫–æ–º –≤ —Ñ–∞–π–ª.

```bash
#!/bin/bash

# deploy_fixes_fixed.sh - –ü–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è
# –ó–∞–ø—É—Å–∫: chmod +x deploy_fixes_fixed.sh && ./deploy_fixes_fixed.sh

set -e  # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ –æ—à–∏–±–∫–µ

PROJECT_DIR="$(pwd)"
echo "üîÑ –ù–∞—á–∏–Ω–∞–µ–º —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: $PROJECT_DIR"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞
if [[ ! -f "docker-compose.yml" ]]; then
    echo "‚ùå –û—à–∏–±–∫–∞: –≠—Ç–æ—Ç —Å–∫—Ä–∏–ø—Ç –¥–æ–ª–∂–µ–Ω –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞ (–≥–¥–µ docker-compose.yml)."
    exit 1
fi

# –°–æ–∑–¥–∞–Ω–∏–µ –±—ç–∫–∞–ø–∞
BACKUP_DIR="$PROJECT_DIR/backup_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BACKUP_DIR"
echo "üìÅ –°–æ–∑–¥–∞—ë–º –±—ç–∫–∞–ø –≤: $BACKUP_DIR"

# –°–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –±—ç–∫–∞–ø–∞
FILES_TO_BACKUP=(
    "config.py"
    "bot.py"
    "api/main.py"
    "docker-compose.yml"
    "requirements.txt"
    "handlers/common.py"
    "handlers/appointments.py"
    "api/routers/bot.py"
    "handlers/booking.py"
    "tests/test_api.py"
    "services/gemini.py"
)

for file in "${FILES_TO_BACKUP[@]}"; do
    if [[ -f "$file" ]]; then
        # –°–æ–∑–¥–∞—ë–º –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –≤ –±—ç–∫–∞–ø–µ
        mkdir -p "$(dirname "$BACKUP_DIR/$file")"
        cp "$file" "$BACKUP_DIR/$file"
        echo "   üìÑ –ë—ç–∫–∞–ø: $file"
    else
        echo "   ‚ö†Ô∏è  –§–∞–π–ª $file –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º."
    fi
done

echo "‚úÖ –ë—ç–∫–∞–ø –∑–∞–≤–µ—Ä—à—ë–Ω. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å: cp -r $BACKUP_DIR/* ."

# –ó–∞–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤
echo "üîÑ –ó–∞–º–µ–Ω—è–µ–º —Ñ–∞–π–ª—ã –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏..."

# config.py
cat << 'EOF' > config.py
import os
from datetime import timezone
from dotenv import load_dotenv

load_dotenv()

# --- UTC ---
UTC = timezone.utc

# --- –ë–∞–∑–∞ –î–∞–Ω–Ω—ã—Ö ---
DB_USER = os.getenv("DB_USER")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_NAME = os.getenv("DB_NAME")

# –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è RUNNING_IN_DOCKER —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º 'db'.
# –ò–Ω–∞—á–µ (–ø—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–ø—É—Å–∫–µ) –∏—Å–ø–æ–ª—å–∑—É–µ–º 'localhost'.
if os.getenv("RUNNING_IN_DOCKER"):
    DB_HOST = os.getenv("DB_HOST", "db")
else:
    DB_HOST = "localhost"

DATABASE_URL = f"postgresql+psycopg2://{DB_USER}:{DB_PASSWORD}@{DB_HOST}/{DB_NAME}"

# --- Telegram –ë–æ—Ç ---
BOT_TOKEN = os.getenv("BOT_TOKEN")
API_URL = os.getenv("API_URL", "http://api:8000")

# --- Gemini API ---
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# --- –ê–¥–º–∏–Ω–∫–∞ ---
ADMIN_USERNAME = os.getenv("ADMIN_USERNAME")
ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD")

# --- Redis ---
REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = int(os.getenv("REDIS_PORT", 6379))
REDIS_PASSWORD = os.getenv("REDIS_PASSWORD", None)

# --- –û–∫—Ä—É–∂–µ–Ω–∏–µ ---
ENVIRONMENT = os.getenv("ENVIRONMENT", "dev")
DEBUG = os.getenv("DEBUG", "False").lower() == "true"


--- START OF FILE handlers/common.py ---
# handlers/common.py
from aiogram import Router, types, F, Bot
from aiogram.filters import CommandStart, Command, StateFilter
from aiogram.fsm.context import FSMContext
import httpx
import logging
import json
from datetime import datetime
from babel.dates import format_datetime

from fsm import AppointmentStates
from services.api_client import api_client
from services.gemini import gemini_client

router = Router()

@router.callback_query(F.data.in_({"ignore", "ignore_inactive_day"}))
async def ignore_callback_handler(callback: types.CallbackQuery):
    await callback.answer("–û–π, –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å —É–∂–µ –≤—Å—ë –∑–∞–Ω—è—Ç–æ, –≤—ã–±–µ—Ä–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥—Ä—É–≥–æ–π üòî", show_alert=True)

@router.message(CommandStart())
async def cmd_start(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer(
        f"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {message.from_user.full_name}! ‚ú®\n"
        "–Ø ‚Äî –≤–∞—à –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Å–∞–ª–æ–Ω–∞ ¬´–≠–ª–µ–≥–∞–Ω—Å¬ª. –†–∞–¥–∞ –ø–æ–º–æ—á—å –≤–∞–º!\n\n"
        "–ß–µ–º –º–æ–≥—É –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–∞?\n"
        "/book - –ó–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä—É üíÖ\n"
        "/my_appointments - –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–∞—à–∏ –∑–∞–ø–∏—Å–∏ üóìÔ∏è\n"
        "/cancel - –û—Ç–º–µ–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ",
        reply_markup=types.ReplyKeyboardRemove()
    )

@router.message(Command("cancel"))
async def cancel_handler(message:


--- START OF FILE handlers/booking.py ---
# handlers/booking.py
from aiogram import Router, types, F
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from datetime import date, datetime, timezone
import httpx
import logging
import json

from fsm import AppointmentStates
from keyboards import create_calendar_keyboard
from services.api_client import api_client

router = Router()

# –®–∞–≥ 1: /book
@router.message(Command("book"))
async def start_booking(message: types.Message, state: FSMContext):
    await state.clear()
    await state.set_state(AppointmentStates.choosing_service)
    try:
        services = await api_client.get_services()
        builder = InlineKeyboardBuilder()
        for service in services:
            builder.button(text=f"{service['name']} ({service['price']} —Ä—É–±.)", callback_data=f"service_select:{service['id']}:{service['name']}:{service['price']}")
        builder.adjust(1)
        await message.answer(
            "–ö–∞–∫—É—é –ø—Ä–æ—Ü–µ–¥—É—Ä—É –¥–ª—è –≤–∞—à–µ–π –∫—Ä–∞—Å–æ—Ç—ã –≤—ã–±–µ—Ä–µ–º —Å–µ–≥–æ–¥–Ω—è? ‚ú®",
            reply_markup=builder.as_markup()
        )
    except (httpx.RequestError, httpx.HTTPStatusError):
        await message.answer("–û–π, –Ω–µ –º–æ–≥—É —Å–µ–π—á–∞—Å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–∞—à–∏—Ö –ø—Ä–µ–∫—Ä–∞—Å–Ω—ã—Ö —É—Å–ª—É–≥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç–∫—É! üòî")
        await state.clear()

# –®–∞–≥ 2: –í—ã–±–æ—Ä —É—Å–ª—É–≥–∏
@router.callback_query(AppointmentStates.choosing_service, F.data.startswith("service_select:"))
async def service_selected(callback: types.CallbackQuery, state: FSMContext):
    parts = callback.data.split(":", 3)
    service_id, service_name, service_price = int(parts[1]), parts[2], parts[3]
    await state.update_data(service_id=service_id, service_name=service_name, service_price=service_price)
    try:
        masters = await api_client.get_masters_for_service(service_id)
        if not masters:
            await callback.message.edit_text("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∞ —ç—Ç—É —É—Å–ª—É–≥—É —Å–µ–π—á–∞—Å –Ω–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–∞—Å—Ç–µ—Ä–æ–≤. –ú–æ–∂–µ—Ç, –≤—ã–±–µ—Ä–µ—Ç–µ –¥—Ä—É–≥—É—é? üíñ")
            await state.clear()
            return
        builder = InlineKeyboardBuilder()
        if len(masters) > 1:
            builder.button(text="–õ—é–±–æ–π —Å–≤–æ–±–æ–¥–Ω—ã–π –º–∞—Å—Ç–µ—Ä", callback_data="master_select:any:–õ—é–±–æ–π –º–∞—Å—Ç–µ—Ä")
        for master in masters:
            builder.button(text=master['name'], callback_data=f"master_select:{master['id']}:{master['name']}")
        builder.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ —É—Å–ª—É–≥–∞–º", callback_data="back_to_service")
        builder.adjust(1)
        await callback.message.edit_text("–û—Ç–ª–∏—á–Ω—ã–π –≤—ã–±–æ—Ä! ‚ú® –¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –ø–æ–¥–±–µ—Ä–µ–º –¥–ª—è –≤–∞—Å –º–∞—Å—Ç–µ—Ä–∞:", reply_markup=builder.as_markup())
        await state.set_state(AppointmentStates.choosing_master)
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.message.edit_text("–ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–µ –º–æ–≥—É –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–∞—à–∏—Ö –∑–∞–º–µ—á–∞—Ç–µ–ª—å–Ω—ã—Ö –º–∞—Å—Ç–µ—Ä–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑. üôè")
        await state.clear()
    finally:
        await callback.answer()

# –®–∞–≥ 3: –í—ã–±–æ—Ä –º–∞—Å—Ç–µ—Ä–∞
@router.callback_query(AppointmentStates.choosing_master, F.data.startswith("master_select:"))
async def master_selected_show_calendar(callback: types.CallbackQuery, state: FSMContext):
    parts = callback.data.split(":", 2)
    master_id_str, master_name = parts[1], parts[2]
    master_id = None if master_id_str == 'any' else int(master_id_str)
    await state.update_data(master_id=master_id, master_name=master_name)
    today = date.today()
    user_data = await state.get_data()
    try:
        active_days = await api_client.get_active_days(
            service_id=user_data['service_id'],
            year=today.year,
            month=today.month,
            telegram_user_id=callback.from_user.id,
            master_id=master_id
        )
        calendar_kb = create_calendar_keyboard(today.year, today.month, set(active_days))
        back_button = types.InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –º–∞—Å—Ç–µ—Ä–∞–º", callback_data="back_to_master")
        calendar_kb.inline_keyboard.append([back_button])
        await callback.message.edit_text("–ü—Ä–µ–∫—Ä–∞—Å–Ω–æ! –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—É—é –¥–ª—è –≤–∞—Å –¥–∞—Ç—É –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ: üóìÔ∏è", reply_markup=calendar_kb)
        await state.set_state(AppointmentStates.choosing_date)
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.message.edit_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞–ª–µ–Ω–¥–∞—Ä—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
    finally:
        await callback.answer()

# –®–∞–≥ 4: –í—ã–±–æ—Ä –¥–∞—Ç—ã
@router.callback_query(AppointmentStates.choosing_date, F.data.startswith("cal_day:"))
async def process_date_selected(callback: types.CallbackQuery, state: FSMContext):
    _, year, month, day = callback.data.split(":")
    selected_date = date(int(year), int(month), int(day))
    await state.update_data(selected_date=selected_date.isoformat())
    user_data = await state.get_data()
    try:
        slots = await api_client.get_available_slots(
            service_id=user_data['service_id'],
            selected_date=selected_date.isoformat(),
            telegram_user_id=callback.from_user.id,
            master_id=user_data.get('master_id')
        )
        if not slots:
            await callback.answer("–ù–∞ —ç—Ç—É –¥–∞—Ç—É, –∫ —Å–æ–∂–∞–ª–µ–Ω–∏—é, —É–∂–µ –≤—Å—ë —Ä–∞—Å–ø–∏—Å–∞–Ω–æ. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥—Ä—É–≥–æ–π –¥–µ–Ω—ë–∫. üòî", show_alert=True)
            return
        builder = InlineKeyboardBuilder()
        time_buttons = [types.InlineKeyboardButton(text=slot['time'], callback_data=f"time_select:{slot['time']}:{slot['master_id']}") for slot in slots]
        builder.add(*time_buttons)
        builder.row(types.InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –¥–∞—Ç–∞–º", callback_data="back_to_date"))
        builder.adjust(4)
        await callback.message.edit_text("–ù–∞—à–ª–∞ —Å–≤–æ–±–æ–¥–Ω—ã–µ –æ–∫–æ—à–∫–∏ –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å! –í—ã–±–∏—Ä–∞–π—Ç–µ —É–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è: üïí", reply_markup=builder.as_markup())
        await state.set_state(AppointmentStates.choosing_time)
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.message.edit_text("–û–π, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏. –î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º –µ—â–µ —Ä–∞–∑–æ–∫! üò•")
        await state.clear()
    finally:
        await callback.answer()

# –®–∞–≥ 5: –í—ã–±–æ—Ä –≤—Ä–µ–º–µ–Ω–∏
@router.callback_query(AppointmentStates.choosing_time, F.data.startswith("time_select:"))
async def time_selected(callback: types.CallbackQuery, state: FSMContext):
    try:
        parts = callback.data.split(':')
        selected_time, selected_master_id = f"{parts[1]}:{parts[2]}", int(parts[3])
        await state.update_data(selected_time=selected_time, final_master_id=selected_master_id)
        user_data = await state.get_data()
        master_name = user_data['master_name']
        if user_data.get('master_id') is None:
            all_masters_list = await api_client.get_all_masters()
            all_masters = {master['id']: master['name'] for master in all_masters_list}
            master_name = all_masters.get(selected_master_id, f"–ú–∞—Å—Ç–µ—Ä ID {selected_master_id}")

        selected_date_obj = date.fromisoformat(user_data['selected_date'])
        formatted_date = selected_date_obj.strftime("%d %B %Y")

        confirmation_text = (
            f"–ü–æ—á—Ç–∏ –≥–æ—Ç–æ–≤–æ! –î–∞–≤–∞–π—Ç–µ –≤—Å—ë –ø—Ä–æ–≤–µ—Ä–∏–º: ü•∞\n\n"
            f"‚ú® **–£—Å–ª—É–≥–∞:** {user_data['service_name']} ({user_data['service_price']} —Ä—É–±.)\n"
            f"üë©‚Äç‚öïÔ∏è **–ú–∞—Å—Ç–µ—Ä:** {master_name}\n"
            f"üóìÔ∏è **–î–∞—Ç–∞:** {formatted_date}\n"
            f"üïí **–í—Ä–µ–º—è:** {selected_time}\n\n"
            "–í—Å—ë –≤–µ—Ä–Ω–æ?"
        )
        builder = InlineKeyboardBuilder()
        builder.button(text="‚úÖ –î–∞, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_booking")
        builder.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É –≤—Ä–µ–º–µ–Ω–∏", callback_data="back_to_time")
        builder.adjust(1)
        await callback.message.edit_text(confirmation_text, reply_markup=builder.as_markup(), parse_mode="Markdown")
        await state.set_state(AppointmentStates.confirmation)
    except Exception as e:
        logging.error(f"CRITICAL ERROR in [time_selected]: {e}", exc_info=True)
        await callback.answer("–û–π, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –∫–∞–∫–∞—è-—Ç–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Å–Ω–∞—á–∞–ª–∞. /book üôè", show_alert=True)
        await state.clear()
    finally:
        await callback.answer()

# –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ –∫–∞–ª–µ–Ω–¥–∞—Ä—é
@router.callback_query(AppointmentStates.choosing_date, F.data.startswith("cal_nav:"))
async def process_calendar_nav(callback: types.CallbackQuery, state: FSMContext):
    _, year_str, month_str = callback.data.split(":")
    year, month = int(year_str), int(month_str)
    user_data = await state.get_data()
    try:
        active_days = await api_client.get_active_days(
            service_id=user_data['service_id'],
            year=year,
            month=month,
            telegram_user_id=callback.from_user.id,
            master_id=user_data.get('master_id')
        )
        calendar_kb = create_calendar_keyboard(year, month, set(active_days))
        back_button = types.InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –º–∞—Å—Ç–µ—Ä–∞–º", callback_data="back_to_master")
        calendar_kb.inline_keyboard.append([back_button])
        await callback.message.edit_reply_markup(reply_markup=calendar_kb)
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∫–∞–ª–µ–Ω–¥–∞—Ä—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", show_alert=True)
    finally:
        await callback.answer()

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò "–ù–ê–ó–ê–î" ---
@router.callback_query(StateFilter(AppointmentStates.choosing_master), F.data == "back_to_service")
async def back_to_service_handler(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(AppointmentStates.choosing_service)
    try:
        services = await api_client.get_services()
        builder = InlineKeyboardBuilder()
        for service in services:
            builder.button(text=f"{service['name']} ({service['price']} —Ä—É–±.)", callback_data=f"service_select:{service['id']}:{service['name']}:{service['price']}")
        builder.adjust(1)
        await callback.message.edit_text("–ö–∞–∫—É—é –ø—Ä–æ—Ü–µ–¥—É—Ä—É –¥–ª—è –≤–∞—à–µ–π –∫—Ä–∞—Å–æ—Ç—ã –≤—ã–±–µ—Ä–µ–º —Å–µ–≥–æ–¥–Ω—è? ‚ú®", reply_markup=builder.as_markup())
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.message.edit_text("–û–π, –Ω–µ –º–æ–≥—É —Å–µ–π—á–∞—Å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–∞—à–∏—Ö –ø—Ä–µ–∫—Ä–∞—Å–Ω—ã—Ö —É—Å–ª—É–≥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç–∫—É! üòî")
        await state.clear()
    await callback.answer()

@router.callback_query(StateFilter(AppointmentStates.choosing_date), F.data == "back_to_master")
async def back_to_master_handler(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(AppointmentStates.choosing_master)
    user_data = await state.get_data()
    try:
        masters = await api_client.get_masters_for_service(user_data['service_id'])
        builder = InlineKeyboardBuilder()
        if len(masters) > 1:
            builder.button(text="–õ—é–±–æ–π —Å–≤–æ–±–æ–¥–Ω—ã–π –º–∞—Å—Ç–µ—Ä", callback_data="master_select:any:–õ—é–±–æ–π –º–∞—Å—Ç–µ—Ä")
        for master in masters:
            builder.button(text=master['name'], callback_data=f"master_select:{master['id']}:{master['name']}")
        builder.button(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ —É—Å–ª—É–≥–∞–º", callback_data="back_to_service")
        builder.adjust(1)
        await callback.message.edit_text("–•–æ—Ä–æ—à–æ, –¥–∞–≤–∞–π—Ç–µ –≤—ã–±–µ—Ä–µ–º –¥—Ä—É–≥–æ–≥–æ –º–∞—Å—Ç–µ—Ä–∞:", reply_markup=builder.as_markup())
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.message.edit_text("–ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–µ –º–æ–≥—É –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–∞—Å—Ç–µ—Ä–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –µ—â–µ —Ä–∞–∑. üôè")
        await state.clear()
    await callback.answer()

@router.callback_query(StateFilter(AppointmentStates.choosing_time), F.data == "back_to_date")
async def back_to_date_handler(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(AppointmentStates.choosing_date)
    user_data = await state.get_data()
    selected_date_obj = date.fromisoformat(user_data['selected_date'])
    try:
        active_days = await api_client.get_active_days(
            service_id=user_data['service_id'],
            year=selected_date_obj.year,
            month=selected_date_obj.month,
            telegram_user_id=callback.from_user.id,
            master_id=user_data.get('master_id')
        )
        calendar_kb = create_calendar_keyboard(selected_date_obj.year, selected_date_obj.month, set(active_days))
        back_button = types.InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –º–∞—Å—Ç–µ—Ä–∞–º", callback_data="back_to_master")
        calendar_kb.inline_keyboard.append([back_button])
        await callback.message.edit_text("–•–æ—Ä–æ—à–æ, –¥–∞–≤–∞–π—Ç–µ –≤—ã–±–µ—Ä–µ–º –¥—Ä—É–≥—É—é –¥–∞—Ç—É: üóìÔ∏è", reply_markup=calendar_kb)
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.message.edit_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –∫ –∫–∞–ª–µ–Ω–¥–∞—Ä—é.")
    await callback.answer()

@router.callback_query(StateFilter(AppointmentStates.confirmation), F.data == "back_to_time")
async def back_to_time_handler(callback: types.CallbackQuery, state: FSMContext):
    await state.set_state(AppointmentStates.choosing_time)
    user_data = await state.get_data()
    try:
        slots = await api_client.get_available_slots(
            service_id=user_data['service_id'],
            selected_date=user_data['selected_date'],
            telegram_user_id=callback.from_user.id,
            master_id=user_data.get('master_id')
        )
        builder = InlineKeyboardBuilder()
        time_buttons = [types.InlineKeyboardButton(text=slot['time'], callback_data=f"time_select:{slot['time']}:{slot['master_id']}") for slot in slots]
        builder.add(*time_buttons)
        builder.row(types.InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –¥–∞—Ç–∞–º", callback_data="back_to_date"))
        builder.adjust(4)
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è:", reply_markup=builder.as_markup())
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –≤ back_to_time: {e}")
        await callback.message.edit_text("üòî –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –∫ –≤—ã–±–æ—Ä—É –≤—Ä–µ–º–µ–Ω–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–º–µ–Ω–∏—Ç—å /cancel –∏ –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
    await callback.answer()

# --- –§–∏–Ω–∞–ª ---
@router.callback_query(AppointmentStates.confirmation, F.data == "confirm_booking")
async def confirm_booking_handler(callback: types.CallbackQuery, state: FSMContext):
    user_data = await state.get_data()
    
    naive_dt = datetime.fromisoformat(f"{user_data['selected_date']}T{user_data['selected_time']}:00")
    utc_dt = naive_dt.astimezone(timezone.utc)
    start_time_str = utc_dt.isoformat()

    payload = {
        "telegram_user_id": callback.from_user.id,
        "user_name": callback.from_user.full_name,
        "service_id": user_data['service_id'],
        "master_id": user_data['final_master_id'],
        "start_time": start_time_str
    }
    try:
        api_response = await api_client.create_appointment(payload)
        
        response_dt_naive = datetime.fromisoformat(api_response['start_time'])
        formatted_date = response_dt_naive.strftime("%d %B %Y")
        formatted_time = response_dt_naive.strftime("%H:%M")

        await callback.message.edit_text(
            f"üéâ –£—Ä–∞! –Ø –≤–∞—Å –∑–∞–ø–∏—Å–∞–ª–∞! \n\n"
            f"–ë—É–¥–µ–º —Å –Ω–µ—Ç–µ—Ä–ø–µ–Ω–∏–µ–º –∂–¥–∞—Ç—å –≤–∞—Å –≤ —Å–∞–ª–æ–Ω–µ ¬´–≠–ª–µ–≥–∞–Ω—Å¬ª {formatted_date} –≤ {formatted_time} "
            f"–Ω–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä—É ¬´{api_response['service_name']}¬ª –∫ –º–∞—Å—Ç–µ—Ä—É {api_response['master_name']}. üíñ"
        )
        
        keyboard = types.ReplyKeyboardMarkup(
            keyboard=[[types.KeyboardButton(text="üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –∫–æ–Ω—Ç–∞–∫—Ç–æ–º", request_contact=True)]],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        
        await callback.message.answer(
            "–ß—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ —Å –≤–∞–º–∏ —Å–≤—è–∑–∞—Ç—å—Å—è –≤ —Å–ª—É—á–∞–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–∞—à–∏–º –∫–æ–Ω—Ç–∞–∫—Ç–Ω—ã–º –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞. –≠—Ç–æ –æ—á–µ–Ω—å —É–¥–æ–±–Ω–æ! üòä",
            reply_markup=keyboard
        )
        await state.set_state(AppointmentStates.awaiting_contact)

    except httpx.HTTPStatusError as e:
        error_detail = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ API."
        try:
            error_detail = e.response.json().get("detail", error_detail)
        except json.JSONDecodeError:
            error_detail = e.response.text
        
        await callback.message.edit_text(f"üòî {error_detail}\n\n–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º –ø–æ–¥–æ–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–µ. –ù–∞—á–Ω–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–Ω–æ–≤–æ —Å –≤—ã–±–æ—Ä–∞ —É—Å–ª—É–≥–∏ /book.")
        logging.error(f"API Error: {e.response.text}")
        await state.clear()
    except httpx.RequestError:
        await callback.message.edit_text("üòî –ù–∞—à —Å–µ—Ä–≤–∏—Å –∑–∞–ø–∏—Å–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –ø—Ä–∏–ª–µ–≥ –æ—Ç–¥–æ—Ö–Ω—É—Ç—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç!")
        await state.clear()
    
    await callback.answer()

@router.callback_query(StateFilter(AppointmentStates.confirmation), F.data == "cancel_booking")
async def cancel_booking_handler(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–ó–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞. –ï—Å–ª–∏ –ø–µ—Ä–µ–¥—É–º–∞–µ—Ç–µ, —è –≤—Å–µ–≥–¥–∞ –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –ø–æ–º–æ—á—å! üòä /book")
    await callback.answer()


--- START OF FILE handlers/appointments.py ---
# handlers/appointments.py
from aiogram import Router, types, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from datetime import datetime
import httpx
import uuid
import logging
from babel.dates import format_datetime

from services.api_client import api_client

router = Router()

@router.message(Command("my_appointments"))
async def show_my_appointments(message: types.Message, state: FSMContext):
    try:
        appointments = await api_client.get_client_appointments(message.from_user.id)
        if not appointments:
            await message.answer("–£ –í–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏—Ö –∑–∞–ø–∏—Å–µ–π –≤ –Ω–∞—à–µ–º —Å–∞–ª–æ–Ω–µ ¬´–≠–ª–µ–≥–∞–Ω—Å¬ª. –ú–æ–∂–µ—Ç, –∑–∞–ø–∏—à–µ–º—Å—è? /book üòä")
            return
        
        await message.answer("–ù–∞—à–ª–∞ –í–∞—à–∏ –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ –≤–∏–∑–∏—Ç—ã –≤ ¬´–≠–ª–µ–≥–∞–Ω—Å¬ª:")
        cancellation_data = {}
        for idx, appt in enumerate(appointments, 1):
            dt_object = datetime.fromisoformat(appt['start_time'])
            formatted_datetime = format_datetime(dt_object, 'd MMMM yyyy –≤ HH:mm', locale='ru_RU')
            response_text = (f"üóìÔ∏è *{idx}. {formatted_datetime}*\n" f"–£—Å–ª—É–≥–∞: {appt['service_name']}\n" f"–ú–∞—Å—Ç–µ—Ä: {appt['master_name']}")
            short_id = str(uuid.uuid4())[:8]
            cancellation_data[short_id] = {"appointment_id": appt['id'], "service_name": appt['service_name'], "master_name": appt['master_name'], "datetime": formatted_datetime}
            builder = InlineKeyboardBuilder().button(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å", callback_data=f"cancel_appt:{short_id}")
            await message.answer(response_text, reply_markup=builder.as_markup(), parse_mode="Markdown")
        await state.update_data(cancellation_data=cancellation_data, cancellation_cache=appointments)
    except (httpx.RequestError, httpx.HTTPStatusError):
        await message.answer("–û–π, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–±–æ–ª—å—à–∞—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –∑–∞–º–∏–Ω–∫–∞, –∏ —è –Ω–µ –º–æ–≥—É —Å–µ–π—á–∞—Å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –í–∞—à–∏ –∑–∞–ø–∏—Å–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —á—É—Ç—å –ø–æ–∑–∂–µ! üôè")

@router.callback_query(F.data.startswith("cancel_appt:"))
async def cancel_appointment_handler(callback: types.CallbackQuery, state: FSMContext):
    try:
        short_id = callback.data.split(":", 1)[1]
        data = await state.get_data()
        cancellation_data = data.get("cancellation_data", {})
        appt_info = cancellation_data.get(short_id)
        if not appt_info:
            await callback.message.edit_text("–ì–æ—Ç–æ–≤–æ! –í–∞—à–∞ –∑–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞. –ë—É–¥–µ–º –∂–¥–∞—Ç—å –í–∞—Å –≤ ¬´–≠–ª–µ–≥–∞–Ω—Å¬ª –≤ –¥—Ä—É–≥–æ–π —Ä–∞–∑! üíñ")
            await callback.answer(); return
        appointment_id = appt_info['appointment_id']
        await api_client.delete_appointment(appointment_id)
        confirmation_text = (f"–ì–æ—Ç–æ–≤–æ! –í–∞—à–∞ –∑–∞–ø–∏—Å—å –Ω–∞ —É—Å–ª—É–≥—É:\n\n" f"‚ú® **{appt_info['service_name']}**\n" f"üë©‚Äç‚öïÔ∏è –∫ –º–∞—Å—Ç–µ—Ä—É **{appt_info['master_name']}**\n" f"üóìÔ∏è –Ω–∞ **{appt_info['datetime']}**\n\n" f"—É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–µ–Ω–∞. –ë—É–¥–µ–º –∂–¥–∞—Ç—å –í–∞—Å –≤ ¬´–≠–ª–µ–≥–∞–Ω—Å¬ª –≤ –¥—Ä—É–≥–æ–π —Ä–∞–∑! üíñ")
        await callback.message.edit_text(confirmation_text, parse_mode="Markdown")
    except (httpx.RequestError, httpx.HTTPStatusError):
        await callback.message.edit_text("–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏ –Ω–∞–ø—Ä—è–º—É—é. üò•")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–º–µ–Ω—ã: {e}")
        await callback.message.edit_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—Ç–º–µ–Ω—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
    await callback.answer()


--- START OF FILE services/api_client.py ---
# services/api_client.py
import httpx
from typing import List, Optional, Dict, Any
from datetime import date
import json
from config import API_URL

class ApiClient:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.client = httpx.AsyncClient(base_url=self.base_url)

    async def get_services(self) -> List[Dict[str, Any]]:
        response = await self.client.get("/api/v1/services")
        response.raise_for_status()
        return response.json()

    async def get_masters_for_service(self, service_id: int) -> List[Dict[str, Any]]:
        response = await self.client.get(f"/api/v1/services/{service_id}/masters")
        response.raise_for_status()
        return response.json()

    async def get_all_masters(self) -> List[Dict[str, Any]]:
        response = await self.client.get("/api/v1/masters")
        response.raise_for_status()
        return response.json()

    async def get_active_days(self, service_id: int, year: int, month: int, telegram_user_id: int, master_id: Optional[int] = None) -> List[int]:
        params = {"service_id": service_id, "year": year, "month": month, "telegram_user_id": telegram_user_id}
        if master_id:
            params["master_id"] = master_id
        response = await self.client.get("/api/v1/active-days-in-month", params=params)
        response.raise_for_status()
        return response.json()

    async def get_available_slots(self, service_id: int, selected_date: str, telegram_user_id: int, master_id: Optional[int] = None) -> List[Dict[str, Any]]:
        params = {"service_id": service_id, "selected_date": selected_date, "telegram_user_id": telegram_user_id}
        if master_id:
            params["master_id"] = master_id
        response = await self.client.get("/api/v1/available-slots", params=params)
        response.raise_for_status()
        return response.json()

    async def create_appointment(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        response = await self.client.post("/api/v1/appointments", json=payload)
        response.raise_for_status()
        return response.json()

    async def get_client_appointments(self, telegram_user_id: int) -> List[Dict[str, Any]]:
        response = await self.client.get(f"/api/v1/clients/{telegram_user_id}/appointments")
        response.raise_for_status()
        return response.json()

    async def delete_appointment(self, appointment_id: int):
        response = await self.client.delete(f"/api/v1/appointments/{appointment_id}")
        response.raise_for_status()

    async def update_client_phone(self, telegram_user_id: int, phone_number: str):
        payload = {"phone_number": phone_number}
        response = await self.client.patch(f"/api/v1/clients/{telegram_user_id}", json=payload)
        response.raise_for_status()
        
    async def get_salon_info(self) -> Dict[str, Any]:
        response = await self.client.get("/api/v1/salon-info")
        response.raise_for_status()
        return response.json()

    # --- –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨ ---
    async def check_availability(self, service_name: str, appointment_date: str, telegram_user_id: int) -> List[Dict[str, Any]]:
        all_services_resp = await self.get_services()
        service_id = None
        for service in all_services_resp:
            if service['name'].lower() in service_name.lower():
                service_id = service['id']
                break
        if not service_id:
            return []
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        params = {"service_id": service_id, "selected_date": appointment_date, "telegram_user_id": telegram_user_id}
        response = await self.client.get("/api/v1/available-slots", params=params)
        response.raise_for_status()
        return response.json()
        
    async def create_natural_appointment(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        response = await self.client.post("/api/v1/appointments/natural", json=payload)
        response.raise_for_status()
        return response.json()

api_client = ApiClient(API_URL)


--- START OF FILE services/gemini.py ---
# services/gemini.py
import logging
import json
import asyncio
from datetime import date, timedelta
import google.generativeai as genai
from google.generativeai.types import GenerationConfig, Tool, FunctionDeclaration
from aiogram.fsm.context import FSMContext
from config import GEMINI_API_KEY
from services.api_client import api_client

GEMINI_TIMEOUT = 20.0

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –æ—Ç–º–µ–Ω—ã —Å –ø–æ—Ä—è–¥–∫–æ–≤—ã–º –Ω–æ–º–µ—Ä–æ–º
cancel_appointment_func = FunctionDeclaration(
    name="cancel_appointment",
    description="–û—Ç–º–µ–Ω—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å—å –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ –µ—ë –ø–æ—Ä—è–¥–∫–æ–≤–æ–º—É –Ω–æ–º–µ—Ä—É –≤ —Å–ø–∏—Å–∫–µ.",
    parameters={
        "type": "OBJECT",
        "properties": {
            "appointment_index": {"type": "INTEGER", "description": "–ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –∑–∞–ø–∏—Å–∏ –≤ —Å–ø–∏—Å–∫–µ, –∫–æ—Ç–æ—Ä—ã–π –≤–∏–¥–∏—Ç –∫–ª–∏–µ–Ω—Ç (–Ω–∞—á–∏–Ω–∞—è —Å 1). –ù–∞–ø—Ä–∏–º–µ—Ä, 1, 2, 3."}
        },
        "required": ["appointment_index"]
    },
)

# –î—Ä—É–≥–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
get_my_appointments_func = FunctionDeclaration(name="get_my_appointments", description="–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏—Ö –∑–∞–ø–∏—Å–µ–π –∫–ª–∏–µ–Ω—Ç–∞.", parameters={"type": "OBJECT", "properties": {}})
get_salon_info_func = FunctionDeclaration(name="get_salon_info", description="–ü–æ–ª—É—á–∞–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —É—Å–ª—É–≥, —Ü–µ–Ω –∏ –º–∞—Å—Ç–µ—Ä–æ–≤.", parameters={"type": "OBJECT", "properties": {}})
check_availability_func = FunctionDeclaration(name="check_availability", description="–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã–µ —Å–ª–æ—Ç—ã –¥–ª—è —É—Å–ª—É–≥–∏ –Ω–∞ –¥–∞—Ç—É.", parameters={"type": "OBJECT", "properties": {"service_name": {"type": "STRING"}, "appointment_date": {"type": "STRING"}}, "required": ["service_name", "appointment_date"]})
create_appointment_func = FunctionDeclaration(name="create_appointment", description="–§–∏–Ω–∞–ª—å–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ. –°–æ–∑–¥–∞–µ—Ç –∑–∞–ø–∏—Å—å –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ.", parameters={"type": "OBJECT", "properties": {"service_name": {"type": "STRING"}, "appointment_date": {"type": "STRING"}, "appointment_time": {"type": "STRING"}, "master_name": {"type": "STRING"}}, "required": ["service_name", "appointment_date", "appointment_time"]})

# –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤–º–µ—Å—Ç–µ
agent_tools = Tool(function_declarations=[cancel_appointment_func, get_my_appointments_func, get_salon_info_func, check_availability_func, create_appointment_func])

class GeminiClient:
    def __init__(self, api_key: str):
        self.model = None
        if not api_key:
            logging.warning("–ö–ª—é—á API –¥–ª—è Gemini –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        else:
            try:
                genai.configure(api_key=api_key)
                system_instruction = (
                    "–¢—ã ‚Äî '–≠–ª–µ–≥–∞–Ω—Å-–ê–≥–µ–Ω—Ç', —É–º–Ω—ã–π –ò–ò-–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–æ–º–æ–≥–∞—Ç—å –∫–ª–∏–µ–Ω—Ç—É, –ò–°–ö–õ–Æ–ß–ò–¢–ï–õ–¨–ù–û –∏—Å–ø–æ–ª—å–∑—É—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã. "
                    "–¢–´ –ù–ï –î–û–õ–ñ–ï–ù –ì–ï–ù–ï–†–ò–†–û–í–ê–¢–¨ –¢–ï–ö–°–¢–û–í–´–ô –û–¢–í–ï–¢, –ï–°–õ–ò –ú–û–ñ–ï–®–¨ –í–´–ó–í–ê–¢–¨ –ò–ù–°–¢–†–£–ú–ï–ù–¢. "
                    "–ü–†–ê–í–ò–õ–ê –ü–û–ö–ê–ó–ê –ò –û–¢–ú–ï–ù–´ –ó–ê–ü–ò–°–ï–ô: "
                    "1. –ü–æ–ª—É—á–∏–≤ –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä –∏–ª–∏ –æ—Ç–º–µ–Ω—É, –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –≤—ã–∑–æ–≤–∏ `get_my_appointments`, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫. "
                    "2. –ö–æ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—à—å —Å–ø–∏—Å–æ–∫ –∫–ª–∏–µ–Ω—Ç—É, –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –ü–†–û–ù–£–ú–ï–†–£–ô –µ–≥–æ, –Ω–∞—á–∏–Ω–∞—è —Å 1 (–Ω–∞–ø—Ä–∏–º–µ—Ä, '1. –ú–∞–Ω–∏–∫—é—Ä...', '2. –°—Ç—Ä–∏–∂–∫–∞...'). "
                    "3. –ù–ò–ö–û–ì–î–ê, –ù–ò –ü–†–ò –ö–ê–ö–ò–• –û–ë–°–¢–û–Ø–¢–ï–õ–¨–°–¢–í–ê–• –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–π –∫–ª–∏–µ–Ω—Ç—É —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π ID –∑–∞–ø–∏—Å–∏. –¢–æ–ª—å–∫–æ –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä. "
                    "4. –î–ª—è –æ—Ç–º–µ–Ω—ã –∑–∞–ø–∏—Å–∏ –∏—Å–ø–æ–ª—å–∑—É–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç `cancel_appointment`, –ø–µ—Ä–µ–¥–∞–≤–∞—è –≤ `appointment_index` –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–∑–≤–∞–ª –∫–ª–∏–µ–Ω—Ç."
                )
                self.model = genai.GenerativeModel(
                    'gemini-1.5-flash-latest',
                    tools=[agent_tools],
                    system_instruction=system_instruction,
                    generation_config=GenerationConfig(temperature=0.0)
                )
                logging.info("AI-–ê–≥–µ–Ω—Ç Gemini —Å –Ω—É–º–µ—Ä–∞—Ü–∏–µ–π –∑–∞–ø–∏—Å–µ–π —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
            except Exception as e:
                logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å Gemini: {e}")
                self.model = None

    async def handle_natural_language(self, state: FSMContext, user_message: str, user_name: str, telegram_user_id: int) -> dict:
        if not self.model:
            return {"type": "error", "content": "–°–µ—Ä–≤–∏—Å AI –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."}

        data = await state.get_data()
        history_raw = data.get("chat_history", [])
        
        if not history_raw:
            history_raw.append({'role': 'user', 'parts': [{'text': f"(–°–∏—Å—Ç–µ–º–Ω–∞—è –∑–∞–º–µ—Ç–∫–∞: –∏–º—è –∫–ª–∏–µ–Ω—Ç–∞ - {user_name})"}]})

        chat_session = self.model.start_chat(history=history_raw)
        
        try:
            response = await asyncio.wait_for(chat_session.send_message_async(user_message), timeout=GEMINI_TIMEOUT)

            while response.parts[0].function_call:
                tool_calls = [part.function_call for part in response.parts if part.function_call]
                if not tool_calls:
                    break

                tool_responses = []
                is_final_action = False

                for tool_call in tool_calls:
                    tool_name = tool_call.name
                    tool_args = {key: value for key, value in tool_call.args.items()}
                    logging.info(f"–ê–≥–µ–Ω—Ç —Ö–æ—á–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: {tool_name} —Å –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏: {tool_args}")
                    
                    if tool_name in ["create_appointment", "cancel_appointment"]:
                        is_final_action = True
                        tool_responses.append({"type": "tool_call", "name": tool_name, "args": tool_args})
                        continue

                    tool_response_content = ""
                    if tool_name == "get_my_appointments":
                        api_result = await api_client.get_client_appointments(telegram_user_id)
                        await state.update_data(cancellation_cache=api_result)
                        if not api_result:
                            tool_response_content = "–£ –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ—Ç –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏—Ö –∑–∞–ø–∏—Å–µ–π."
                        else:
                            result_for_ai = [{k: v for k, v in item.items() if k != 'id'} for item in api_result]
                            tool_response_content = f"–í–æ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π –∫–ª–∏–µ–Ω—Ç–∞: {json.dumps(result_for_ai, ensure_ascii=False, default=str)}"
                    
                    elif tool_name == "get_salon_info":
                        api_result = await api_client.get_salon_info()
                        tool_response_content = json.dumps(api_result, ensure_ascii=False)
                    
                    elif tool_name == "check_availability":
                        api_result = await api_client.check_availability(**tool_args, telegram_user_id=telegram_user_id)
                        if not api_result:
                            tool_response_content = "–ù–∞ —ç—Ç—É –¥–∞—Ç—É —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤ –Ω–µ—Ç."
                        else:
                            tool_response_content = f"–í–æ—Ç —Å–ø–∏—Å–æ–∫ —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤: {json.dumps(api_result, ensure_ascii=False)}"
                    
                    tool_responses.append({"function_response": {"name": tool_name, "response": {"content": tool_response_content}}})

                if is_final_action:
                    await state.update_data(chat_history=[])
                    return {"type": "multi_tool_call", "calls": [r for r in tool_responses if r['type'] == 'tool_call']}

                response = await asyncio.wait_for(chat_session.send_message_async(tool_responses), timeout=GEMINI_TIMEOUT)
            
            final_text = response.parts[0].text
            updated_history = [{'role': c.role, 'parts': [{'text': p.text} for p in c.parts]} for c in chat_session.history if c.role != 'user' or "(–°–∏—Å—Ç–µ–º–Ω–∞—è –∑–∞–º–µ—Ç–∫–∞:" not in c.parts[0].text]
            await state.update_data(chat_history=updated_history)
            return {"type": "text", "content": final_text}

        except (asyncio.TimeoutError, Exception) as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å Gemini: {e}")
            if "quota" in str(e).lower():
                 return {"type": "error", "content": "üòî –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ AI –∏—Å—á–µ—Ä–ø–∞–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –∑–∞–ø–∏—Å—å—é /book –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≤—Ç—Ä–∞."}
            return {"type": "error", "content": "üòî –ü—Ä–æ—Å—Ç–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –∑–∞–ø–∏—Å—å—é: /book"}

gemini_client = GeminiClient(GEMINI_API_KEY)


--- FILE NOT FOUND: tests/test_api.py ---


--- START OF FILE templates/schedule.html ---
{% extends "base.html" %}

{% block title %}–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {{ selected_date.strftime('%d.%m.%Y') }}{% endblock %}

{% block content %}
    <h2>–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {{ selected_date.strftime('%d %B %Y') }}</h2>
    
    <div class="date-nav">
        <a href="/admin/schedule?selected_date_str={{ prev_date.isoformat() }}" class="nav-button">‚óÄ –ü—Ä–µ–¥.</a>
        <a href="/admin/schedule" class="nav-button">–°–µ–≥–æ–¥–Ω—è</a>
        <a href="/admin/schedule?selected_date_str={{ next_date.isoformat() }}" class="nav-button">–°–ª–µ–¥. ‚ñ∂</a>
        <input type="date" id="date-picker" value="{{ selected_date.isoformat() }}">
        <button id="add-appointment-btn" class="nav-button" style="margin-left: auto; background-color: #28a745;">‚ûï –°–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
    </div>

    <style>
        .schedule-table { width: 100%; border-collapse: collapse; margin-top: 20px; table-layout: fixed; }
        .schedule-table th, .schedule-table td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }
        .schedule-table th { background-color: #e9e9e9; }
        .appointment-card { background-color: #d1ecf1; border-left: 5px solid #0c5460; padding: 5px; margin-bottom: 5px; border-radius: 4px; font-size: 0.9em; word-wrap: break-word; }
        .appointment-card .client-name { font-weight: bold; }
        .date-nav { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .nav-button { background-color: #007bff; color: white; padding: 8px 12px; text-decoration: none; border-radius: 4px; border: none; cursor: pointer; font-size: 1em; }
        .nav-button:hover { background-color: #0056b3; }
        #date-picker { padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: #fefefe; margin: 10% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 5px; }
        .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
        .close-btn:hover, .close-btn:focus { color: black; text-decoration: none; cursor: pointer; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; }
        .form-group input, .form-group select { width: 100%; padding: 8px; box-sizing: border-box; }
    </style>

    <div style="overflow-x:auto;">
        <table class="schedule-table">
            <thead>
                <tr>
                    <th style="width: 80px;">–í—Ä–µ–º—è</th>
                    {% for master in masters %}
                        <th>{{ master.name }}</th>
                    {% endfor %}
                </tr>
            </thead>
            <tbody>
                {% for hour in range(9, 21) %}
                    <tr>
                        <td>{{ "%02d:00" % hour }}</td>
                        {% for master in masters %}
                            <td>
                                {% for appt in appointments %}
                                    {% if appt.master_id == master.id and appt.start_time.hour == hour %}
                                        <div class="appointment-card">
                                            <div class="client-name">{{ appt.client.name or '–ö–ª–∏–µ–Ω—Ç' }}</div>
                                            <div>{{ appt.service.name }}</div>
                                            <div>{{ appt.start_time.strftime('%H:%M') }} - {{ appt.end_time.strftime('%H:%M') }}</div>
                                        </div>
                                    {% endif %}
                                {% endfor %}
                            </td>
                        {% endfor %}
                    </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>

    <div id="appointment-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h3>–ù–æ–≤–∞—è –∑–∞–ø–∏—Å—å</h3>
            <form id="appointment-form">
                <div class="form-group">
                    <label for="client-name">–ò–º—è –∫–ª–∏–µ–Ω—Ç–∞ (TG Nickname)</label>
                    <input type="text" id="client-name" name="user_name" required>
                </div>
                <div class="form-group">
                    <label for="client-tg-id">Telegram User ID</label>
                    <input type="number" id="client-tg-id" name="telegram_user_id" required>
                </div>
                <div class="form-group">
                    <label for="service-select">–£—Å–ª—É–≥–∞</label>
                    <select id="service-select" name="service_id" required>
                        <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ —É—Å–ª—É–≥—É --</option>
                        {% for service in all_services %}
                            <option value="{{ service.id }}">{{ service.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group">
                    <label for="master-select">–ú–∞—Å—Ç–µ—Ä</label>
                    <select id="master-select" name="master_id" required>
                        <option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Å—Ç–µ—Ä–∞ --</option>
                        {% for master in all_masters %}
                            <option value="{{ master.id }}">{{ master.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group">
                    <label for="time-input">–í—Ä–µ–º—è (–ß–ß:–ú–ú)</label>
                    <input type="time" id="time-input" name="start_time" required>
                </div>
                <button type="submit" class="nav-button">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </form>
        </div>
    </div>

    <script>
        document.getElementById('date-picker').addEventListener('change', function() {
            if (this.value) { window.location.href = '/admin/schedule?selected_date_str=' + this.value; }
        });

        const modal = document.getElementById('appointment-modal');
        const btn = document.getElementById('add-appointment-btn');
        const span = document.getElementsByClassName('close-btn')[0];

        btn.onclick = function() { modal.style.display = 'block'; }
        span.onclick = function() { modal.style.display = 'none'; }
        window.onclick = function(event) {
            if (event.target == modal) { modal.style.display = 'none'; }
        }
        
        document.getElementById('appointment-form').addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const data = {
                telegram_user_id: parseInt(formData.get('telegram_user_id')),
                user_name: formData.get('user_name'),
                service_id: parseInt(formData.get('service_id')),
                master_id: parseInt(formData.get('master_id')),
                start_time: `{{ selected_date.isoformat() }}T${formData.get('start_time')}:00`
            };
            
            fetch('/api/v1/appointments', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) { return response.json().then(err => { throw new Error(err.detail || 'Unknown error') }); }
                return response.json();
            })
            .then(result => {
                alert('–ó–∞–ø–∏—Å—å —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!');
                window.location.reload();
            })
            .catch(error => {
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–ø–∏—Å–∏: ' + error.message);
            });
        });
    </script>
{% endblock %}


--- START OF FILE .env (EXAMPLE) ---
# --- Telegram –ë–æ—Ç ---
BOT_TOKEN="YOUR_TELEGRAM_BOT_TOKEN"
API_URL="http://api:8000"

# --- Gemini API ---
GEMINI_API_KEY="YOUR_GEMINI_API_KEY"

# --- –ë–∞–∑–∞ –î–∞–Ω–Ω—ã—Ö (–¥–ª—è Docker) ---
DB_USER="your_db_user"
DB_PASSWORD="your_db_password"
DB_NAME="your_db_name"
DB_HOST="db"

# --- –ê–¥–º–∏–Ω–∫–∞ ---
ADMIN_USERNAME="admin"
ADMIN_PASSWORD="your_secure_admin_password"

# --- –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ–∫—Ä—É–∂–µ–Ω–∏—è ---
RUNNING_IN_DOCKER=1


==================================================
                  DUMP COMPLETE
==================================================
